====================================================================
                USER MANUAL – ALU 74181 SIMULATOR
====================================================================

────────────────────────────────────────────────────────────────────
▶ SHORT DESCRIPTION
────────────────────────────────────────────────────────────────────
This program is a Simulator of the Arithmetic and Logic Unit (ALU) 74181.
The ALU is the “brain” of a computer, responsible for mathematical
(Arithmetic) and logical (AND, OR, NOT) operations.

The tool is designed for educational purposes and to test the logical functions
of the 74181 chip.

────────────────────────────────────────────────────────────────────
▶ STARTUP INSTRUCTIONS
────────────────────────────────────────────────────────────────────

1. In the project page, press the “Code” button to create and activate
a new virtual development environment (codespace).

2. Compile the C source code and create the executable:
      gcc main.c -o simulator

3. Run the executable:
      ./simulator

4. The main menu will appear:
    
    - the main menu is displayed in Italian by default,
    but it can be changed to another language using the option:
    [7] Cambiare lingua (Italiano/Inglese)

   ===========================================================
   =                   SIMULATORE ALU 74181                 =
   ===========================================================
   [0] Exit
   [1] 4-bit ALU 74181
   [2] 4-bit ALU 74181 (with clock)
   [3] Binary to Decimal Converter
   [4] Decimal to Binary Converter
   [5] 32-bit ALU - 8x74181
   [6] 32-bit ALU - 8x74181 (with clock) 
   [7] Change language (Italian/English)
   ===========================================================


====================================================================
                     1. 4-bit ALU 74181
====================================================================

INPUT MODE
─────────────────
After selecting [1], the program will ask:
    Enter data manually? (Y/N):

Answer:
    • Y → input from keyboard
    • N → read from file "input_alu.txt"

────────────────────────────────────────────────────────────────────
SECTION A: MANUAL INPUT (Y)
────────────────────────────────────────────────────────────────────

Enter the values 0 or 1 for:

    • Cn → Carry-in signal
    • M → Mode selector (0 = arithmetic, 1 = logic)
    • A0–A3, B0–B3 → Binary operands (4 bits each)
    • S0–S3 → Operation selectors

────────────────────────────────────────────────────────────────────
OUTPUT AND RESULTS
────────────────────────────────────────────────────────────────────

╔═══════════════════════════════════════════════╗
║           ALU 74181 RESULTS                   ║
╠═══════════════════════════════════════════════╣
║  F0  = ...                                    ║
║  F1  = ...                                    ║
║  F2  = ...                                    ║
║  F3  = ...                                    ║
║  Cn+4 = ...                                   ║
║  A=B  = ...                                   ║
║  P    = ...                                   ║
║  G    = ...                                   ║
╚═══════════════════════════════════════════════╝

Results are also saved in:
    "results_alu_74181.txt"

────────────────────────────────────────────────────────────────────
SECTION B: INPUT VIA FILE (N)
────────────────────────────────────────────────────────────────────

Required file: "input_alu.txt"
The program will automatically generate it if missing.

File format:
   Cn: <0>
   M:  <0>
   A0: <0>   
   B0: <0>
   A1: <0>   
   B1: <0>
   A2: <0>   
   B2: <0>
   A3: <0>   
   B3: <0>
   S0: <0>   
   S1: <0>   
   S2: <0>   
   S3: <0>

====================================================================
                2. 4-bit ALU 74181 (with clock)
====================================================================

Identical to option [1], but includes a fixed delay to simulate the
propagation time of the logic circuit.

====================================================================
                 3. Binary to Decimal Converter
====================================================================

Input:
   • Manual (Y) → Enter binary number
   • From file (N) → File "input_bin.txt"

Output:
   ╔═════════════════════════════════════════════╗
   ║        CONVERTER RESULTS                    ║
   ╚═════════════════════════════════════════════╝
   Result = <...>

Result saved in "results_dec.txt".

====================================================================
                    4. Decimal to Binary Converter
====================================================================

Input:
   • Manual (Y) → Enter decimal number
   • From file (N) → File "input_dec.txt"

Output:
   ╔═════════════════════════════════════════════╗
   ║        CONVERTER RESULTS                    ║
   ╚═════════════════════════════════════════════╝
   Result = <...>

Result saved in "results_bin.txt".

====================================================================
                    5–6. 32-bit ALU - 8x74181
====================================================================

Simulates 8 cascaded 74181 chips.
Option [6] includes clock delay.

Input:
   Operands (32-bit decimal numbers): A, B
   Signals: Cn, M, S0–S3

Modes:
   • Manual (Y)
   • From file (N): "input_alu32.txt"
    Operand A: <0>
    Operand B: <0>
    Cn: <0>
    M: <0>
    S0: <0>
    S1: <0>
    S2: <0>
    S3: <0>

Output:
   ╔═════════════════════════════════════════════╗
   ║           ALU 32bit RESULTS                 ║
   ╚═════════════════════════════════════════════╝
   Result = <...> (32-bit decimal number)

Result saved in "results_alu32.txt".

====================================================================
        ALU FUNCTION REFERENCE TABLE (OPTIONS 1, 2, 5, 6)
====================================================================

| M | S3 | S2 | S1 | S0 | Cn |           Operation            | 
|---|----|----|----|----|----|--------------------------------|
| 1 | 0  | 0  | 0  | 0  | X  | F = NOT(A)                     |
| 1 | 0  | 0  | 0  | 1  | X  | F = NOT(A + B)                 |
| 1 | 0  | 0  | 1  | 0  | X  | F = NOT(A)*B                   |
| 1 | 0  | 0  | 1  | 1  | X  | F = 0                          |
| 1 | 0  | 1  | 0  | 0  | X  | F = NOT(AB)                    |
| 1 | 0  | 1  | 0  | 1  | X  | F = NOT(B)                     |
| 1 | 0  | 1  | 1  | 0  | X  | F = A ⊕ B                     |
| 1 | 0  | 1  | 1  | 1  | X  | F = A*NOT(B)                   |
| 1 | 1  | 0  | 0  | 0  | X  | F = NOT(A)+B                   |
| 1 | 1  | 0  | 0  | 1  | X  | F = NOT(A ⊕ B)                |
| 1 | 1  | 0  | 1  | 0  | X  | F = B                          |
| 1 | 1  | 0  | 1  | 1  | X  | F = AB                         |
| 1 | 1  | 1  | 0  | 0  | X  | F = 1                          |
| 1 | 1  | 1  | 0  | 1  | X  | F = A + NOT(B)                 |
| 1 | 1  | 1  | 1  | 0  | X  | F = A + B                      |
| 1 | 1  | 1  | 1  | 1  | X  | F = A                          |
| 0 | 0  | 0  | 0  | 0  | 0  | F = A PLUS 1                   |
| 0 | 0  | 0  | 0  | 1  | 0  | F = (A + B) PLUS 1             |
| 0 | 0  | 0  | 1  | 0  | 0  | F = (A + NOT(B)) PLUS 1        |
| 0 | 0  | 0  | 1  | 1  | 0  | F = 0                          |
| 0 | 0  | 1  | 0  | 0  | 0  | F = A PLUS (A*NOT(B)) PLUS 1   |
| 0 | 0  | 1  | 0  | 1  | 0  | F = (A+B) PLUS A*NOT(B) PLUS 1 |
| 0 | 0  | 1  | 1  | 0  | 0  | F = A MINUS B                  |
| 0 | 0  | 1  | 1  | 1  | 0  | F = A*NOT(B)                   |
| 0 | 1  | 0  | 0  | 0  | 0  | F = A PLUS AB PLUS 1           |
| 0 | 1  | 0  | 0  | 1  | 0  | F = A PLUS B PLUS 1            |
| 0 | 1  | 0  | 1  | 0  | 0  | F = (A+NOT(B)) PLUS AB PLUS 1  |
| 0 | 1  | 0  | 1  | 1  | 0  | F = AB                         |
| 0 | 1  | 1  | 0  | 0  | 0  | F = A PLUS A PLUS 1            |
| 0 | 1  | 1  | 0  | 1  | 0  | F = (A+B) PLUS A PLUS 1        |
| 0 | 1  | 1  | 1  | 0  | 0  | F = (A+NOT(B)) PLUS A PLUS 1   |
| 0 | 1  | 1  | 1  | 1  | 0  | F = A                          |
| 0 | 0  | 0  | 0  | 0  | 1  | F = A                          |
| 0 | 0  | 0  | 0  | 1  | 1  | F = A + B                      |
| 0 | 0  | 0  | 1  | 0  | 1  | F = A + NOT(B)                 |
| 0 | 0  | 0  | 1  | 1  | 1  | F = -1                         |
| 0 | 0  | 1  | 0  | 0  | 1  | F = A PLUS A*NOT(B)            |
| 0 | 0  | 1  | 0  | 1  | 1  | F = (A+B) PLUS A*NOT(B)        |
| 0 | 0  | 1  | 1  | 0  | 1  | F = A MINUS B MINUS 1          |
| 0 | 0  | 1  | 1  | 1  | 1  | F = A*NOT(B) MINUS 1           |
| 0 | 1  | 0  | 0  | 0  | 1  | F = A PLUS AB                  |
| 0 | 1  | 0  | 0  | 1  | 1  | F = A PLUS B                   |
| 0 | 1  | 0  | 1  | 0  | 1  | F = (A+NOT(B)) PLUS AB         |
| 0 | 1  | 0  | 1  | 1  | 1  | F = AB MINUS 1                 |
| 0 | 1  | 1  | 0  | 0  | 1  | F = A PLUS A                   |
| 0 | 1  | 1  | 0  | 1  | 1  | F = (A+B) PLUS A               |
| 0 | 1  | 1  | 1  | 0  | 1  | F = (A+NOT(B) PLUS A           |
| 0 | 1  | 1  | 1  | 1  | 1  | F = A MINUS 1                  |
───────────────────────────────────────────────────────────────
Legend:
   X → don’t care value
   * → AND
   + → OR
   ⊕ → XOR
   PLUS / MINUS → arithmetic operations